# 实验三：朴素贝叶斯算法实验

#### 【实验目的】

理解朴素贝叶斯算法原理，掌握朴素贝叶斯算法框架。

#### 【实验内容】

1. 针对下表中的数据，编写python程序实现朴素贝叶斯算法（不使用sklearn包），对输入数据进行预测；
2. 熟悉sklearn库中的朴素贝叶斯算法，使用sklearn包编写朴素贝叶斯算法程序，对输入数据进行预测；

#### 【实验报告要求】

1. 对照实验内容，撰写实验过程、算法及测试结果；
2. 代码规范化：命名规则、注释；
3. 查阅文献，讨论朴素贝叶斯算法的应用场景。



| 色泽 | 根蒂 | 敲声 | 纹理 | 脐部 | 触感 | 好瓜 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 青绿 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 碍滑 | 是   |
| 乌黑 | 蜷缩 | 沉闷 | 清晰 | 凹陷 | 碍滑 | 是   |
| 乌黑 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 碍滑 | 是   |
| 青绿 | 蜷缩 | 沉闷 | 清晰 | 凹陷 | 碍滑 | 是   |
| 浅白 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 碍滑 | 是   |
| 青绿 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 软粘 | 是   |
| 乌黑 | 稍蜷 | 浊响 | 稍糊 | 稍凹 | 软粘 | 是   |
| 乌黑 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 硬滑 | 是   |
| 乌黑 | 稍蜷 | 沉闷 | 稍糊 | 稍凹 | 硬滑 | 否   |
| 青绿 | 硬挺 | 清脆 | 清晰 | 平坦 | 软粘 | 否   |
| 浅白 | 硬挺 | 清脆 | 模糊 | 平坦 | 硬滑 | 否   |
| 浅白 | 蜷缩 | 浊响 | 模糊 | 平坦 | 软粘 | 否   |
| 青绿 | 稍蜷 | 浊响 | 稍糊 | 凹陷 | 硬滑 | 否   |
| 浅白 | 稍蜷 | 沉闷 | 稍糊 | 凹陷 | 硬滑 | 否   |
| 乌黑 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 软粘 | 否   |
| 浅白 | 蜷缩 | 浊响 | 模糊 | 平坦 | 硬滑 | 否   |
| 青绿 | 蜷缩 | 沉闷 | 稍糊 | 稍凹 | 硬滑 | 否   |



##### 编写python程序实现朴素贝叶斯算法（不使用sklearn包）：

对已下数据进行预测：

| 编号 | 色泽 | 根蒂 | 敲声 | 纹理 | 脐部 | 触感 | 好瓜 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 测1  | 青绿 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 硬滑 |  ？  |

1. 导入数据：

```python
# 导入数据
import pandas as pd

df = pd.read_csv("../data/data_word.csv")
df
```

输出：

|      | 色泽 | 根蒂 | 敲声 | 纹理 | 脐部 | 触感 | 好瓜 |
| ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: |
|    0 | 青绿 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 硬滑 |   是 |
|    1 | 乌黑 | 蜷缩 | 沉闷 | 清晰 | 凹陷 | 硬滑 |   是 |
|    2 | 乌黑 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 硬滑 |   是 |
|    3 | 青绿 | 蜷缩 | 沉闷 | 清晰 | 凹陷 | 硬滑 |   是 |
|    4 | 浅白 | 蜷缩 | 浊响 | 清晰 | 凹陷 | 硬滑 |   是 |
|    5 | 青绿 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 软粘 |   是 |
|    6 | 乌黑 | 稍蜷 | 浊响 | 稍糊 | 稍凹 | 软粘 |   是 |
|    7 | 乌黑 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 硬滑 |   是 |
|    8 | 乌黑 | 稍蜷 | 沉闷 | 稍糊 | 稍凹 | 硬滑 |   否 |
|    9 | 青绿 | 硬挺 | 清脆 | 清晰 | 平坦 | 软粘 |   否 |
|   10 | 浅白 | 硬挺 | 清脆 | 模糊 | 平坦 | 硬滑 |   否 |
|   11 | 浅白 | 蜷缩 | 浊响 | 模糊 | 平坦 | 软粘 |   否 |
|   12 | 青绿 | 稍蜷 | 浊响 | 稍糊 | 凹陷 | 硬滑 |   否 |
|   13 | 浅白 | 稍蜷 | 沉闷 | 稍糊 | 凹陷 | 硬滑 |   否 |
|   14 | 乌黑 | 稍蜷 | 浊响 | 清晰 | 稍凹 | 软粘 |   否 |
|   15 | 浅白 | 蜷缩 | 浊响 | 模糊 | 平坦 | 硬滑 |   否 |
|   16 | 青绿 | 蜷缩 | 沉闷 | 稍糊 | 稍凹 | 硬滑 |   否 |

2. 处理数据：

```python
data = df.values[:, 1:-1]
test = df.values[0,1:-1]
labels = df.values[:,-1].tolist()
```

3. 计算先验概率：

$$
P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}
$$

代码：

```python
prob_good = log((8 + 1) / float(17 + 2))
prob_bad = log((9 + 1) / float(17 + 2))
```

4. 计算条件概率:

$$
P\left(X^{(j)}=a_{j l} \mid Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}
$$

代码：

```python
count_good = 0
count_bad = 0
for column in range(len(data)):
	if test[i] == data[column,i]:
		if labels[column] == 1:
			count_good += 1
		if labels[column] == 0:
			count_bad += 1
prob_good += log(float(count_good + 1) / (8 + class_number(i)))
prob_bad += log(float(count_bad + 1) / (9 + class_number(i)))
```

5. 完整代码：

```python
# 使用拉普拉斯修正的朴素贝叶斯分类器，这种情况是对第一行的数据进行测试
import numpy as np
import pandas as pd 
from math import log, exp, pow, sqrt, pi

# exp(x)：e的x次方；pow(x,y)：x的y次方
df = pd.read_csv('../data/data_word.csv')
data = df.values[:, 1:-1]
test = df.values[0,1:-1]
labels = df.values[:,-1].tolist()

def class_number(index):
	class_number = {}
	for column in data:
		if column[index] not in class_number.keys():
			class_number[column[index]] = 0
		class_number[column[index]] += 1
	num = len(class_number)
	return num

def continue_para(num, index):
	ave = 0.0
	var = 0.0
	count = 0
	for column in range(len(data)):
		if labels[column] == num:
			count += 1
			ave += data[column,index]
	ave = ave / count   # 求均值
	for column in range(len(data)):
		if labels[column] == num:
			var += (data[column,index] - ave) * (data[column,index] - ave)
	var = var / count	# 求方差
	return ave,var

prob_good = log((8 + 1) / float(17 + 2))
prob_bad = log((9 + 1) / float(17 + 2))

for i in range(len(data[0])):
	if type(test[i]).__name__ == 'float':    # 当特征是连续的时候
		ave0, var0 = continue_para(0, i)
		ave1, var1 = continue_para(1, i)
		# 带入到连续的公式中
		prob0 = exp(- pow(test[i] - ave0, 2) / (2 * var0)) / sqrt(2 * pi * var0)
		prob1 = exp(- pow(test[i] - ave1, 2) / (2 * var1)) / sqrt(2 * pi * var1)
		prob_good += log(prob1)
		prob_bad += log(prob0)
	else:
		count_good = 0
		count_bad = 0
		for column in range(len(data)):
			if test[i] == data[column,i]:
				if labels[column] == 1:
					count_good += 1
				if labels[column] == 0:
					count_bad += 1
		prob_good += log(float(count_good + 1) / (8 + class_number(i)))
		prob_bad += log(float(count_bad + 1) / (9 + class_number(i)))

print('是好西瓜的概率: %f' % prob_good)
print('是坏西瓜的概率: %f' % prob_bad)
if prob_good >= prob_bad:
	print('最后预测的结果: good watermelon')
else:
	print('最后预测的结果: bad watermelon')
```

输出预测结果：

```
是好西瓜的概率: -12.641381
是坏西瓜的概率: -12.979376
最后预测的结果: 是好西瓜
```

